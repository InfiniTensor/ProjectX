# 开发文档

## 日志的用法

### 日志库

日志库采用 [*fmtlog*](https://github.com/MengRao/fmtlog)，是综合考量易用性、开销和性能的结果。

常见的 c++ 日志库中，[*spdlog*](https://github.com/gabime/spdlog) 使用最为广泛，而 [*NanoLog*](https://github.com/PlatformLab/NanoLog) 具有最好的延迟和吞吐性能表现。*NanoLog* 的延迟和吞吐性能都是由其实现原理决定的，单纯的优化操作无法提升到此种程度。然而，这两方面性能是由两种正交的技术分别驱动的，通常其低延迟能力不必付出多少代价，但为了将吞吐量提高到如此程度，需要对日志输出进行压缩，这牺牲了日志的易用性——必须使用配套工具对日志解压，然后才能供人类阅读。因此，出现了许多学习 *NanoLog* 低延迟能力但放弃其吞吐量的日志库，*fmtlog* 是其中之一。

顾名思义，*fmtlog* 借助 *fmt* 库实现字符串格式化。*fmt* 库高度模板化，将许多字符串操作转移到编译器执行，这同时提高了程序的安全性和性能，常常为关注性能的程序使用。*fmtlog* 将日志分为 5 个级别：`DBG`、`INF`、`WRN`、`ERR`、`OFF`，其中 `INF` 为默认级别，只通过 `fmtlog::setLogLevel(fmtlog::LogLevel:: ... );` 控制。可以使用缩写 `logd`、`logi`、`logw`、`loge`、`logo` 添加。

### 使用规则

1. 重要流程的结尾应加 `logi`，记录此流程计算结果的摘要；
2. 流程中可酌情添加 `logd`，不要加太多，格式统一为 `<类/文件名>/<方法/函数名>: 调试信息`，方便查找；
3. TODO
