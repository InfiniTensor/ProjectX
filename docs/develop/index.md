# 开发文档

## 计算图下降到 kernel 的设计方案

在维持拓扑不变的前提下，利用 `Graph<Node,Edge>` 结构，计算图可以经过 3 步下降到 kernel 网络。

1. 收集 kernel 选择信息

   下降的第一步是根据 kernel 选择的需求移动信息。计算图中，张量持有其数据类型和形状是自然而然的，但对于 kernel 选择来说，kernel 更需要这些信息。因此，在第一步中，计算图算子以及其所有输入输出的数据类型和形状将传递到 kernel 选择器（`KernelSelector`）。并非所有选择器都需要保存所有信息，许多算子对输入输出的形状并不敏感，它们可以选择丢弃这些形状。

   脱去这些信息后，张量变为内存块，包括一个以字节为单位的大小，以及可能已分配的位于主存或显存的数据。根据前端的需求，可能还有一个用于调试的名字和一个用于指导其地址空间的段名。

2. kernel 选择

   Kernel 选择器已经收集到全部信息后，可以进行 kernel 选择了。根据所在硬件，选择器可以从一组相同语义的 kernel 实现中选择一个。是否 inplace 计算是 kernel 实现的一种性质（一个 kernel 实现可以向外部指示其哪些输出会出现在哪些输入的地址上）。kernel 实现可以依赖 tuning，许多算子可以通过各自生成随机数的方式并行执行 tuning。

   选中的 kernel 实现可能是一个类实例，它不需要算子类型了，可以重新组织算子的属性，并且可能具有如何读写相连内存块的细节信息（*layout*、*stride* 或其他表示）。

3. 内存分配

   在所有 kernel 都选中具体实现后，内存分配器得到了足够的信息进行分配。根据内存块的大小、需求的段名、以及相连的 kernel 对 inplace 的需求，内存分配器将所有内存块分配到不同的段中，此时内存块转换到一个其段名和段内偏移的结构。

最终，一个以 kernel 实现类为节点、段址为边的 `Graph<Kernel, Address>` 可以继续传递。它可以直接交给运行时或经过一个过程以组织和重排片上的流（*Stream*）。

## 日志的用法

### 日志库

日志库采用 [*fmtlog*](https://github.com/MengRao/fmtlog)，是综合考量易用性、开销和性能的结果。

常见的 c++ 日志库中，[*spdlog*](https://github.com/gabime/spdlog) 使用最为广泛，而 [*NanoLog*](https://github.com/PlatformLab/NanoLog) 具有最好的延迟和吞吐性能表现。*NanoLog* 的延迟和吞吐性能都是由其实现原理决定的，单纯的优化操作无法提升到此种程度。然而，这两方面性能是由两种正交的技术分别驱动的，通常其低延迟能力不必付出多少代价，但为了将吞吐量提高到如此程度，需要对日志输出进行压缩，这牺牲了日志的易用性——必须使用配套工具对日志解压，然后才能供人类阅读。因此，出现了许多学习 *NanoLog* 低延迟能力但放弃其吞吐量的日志库，*fmtlog* 是其中之一。

顾名思义，*fmtlog* 借助 *fmt* 库实现字符串格式化。*fmt* 库高度模板化，将许多字符串操作转移到编译器执行，这同时提高了程序的安全性和性能，常常为关注性能的程序使用。*fmtlog* 将日志分为 5 个级别：`DBG`、`INF`、`WRN`、`ERR`、`OFF`，其中 `INF` 为默认级别，只通过 `fmtlog::setLogLevel(fmtlog::LogLevel:: ... );` 控制。可以使用缩写 `logd`、`logi`、`logw`、`loge`、`logo` 添加。

### 使用规则

1. 重要流程的结尾应加 `logi`，记录此流程计算结果的摘要；
2. 流程中可酌情添加 `logd`，不要加太多，格式统一为 `<类/文件名>/<方法/函数名>: 调试信息`，方便查找；
3. TODO
